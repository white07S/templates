Short version: Crush tries to download the provider registry on startup. In a locked-down network it can’t reach that URL, so it dies with “failed to load providers.” You have two clean work-arounds:

⸻

Option A — Run 100% offline by pointing Crush to a local providers file
	1.	Create a providers file locally (YAML or JSON—either is fine if you mirror Crush’s schema). Save it somewhere readable, e.g. /etc/crush/providers.yaml or ~/.config/crush/providers.yaml.

Minimal example for an OpenAI-compatible endpoint (vLLM):

providers:
  - id: local-vllm
    name: Local vLLM
    client: openai          # openai-compatible client
    base_url: http://127.0.0.1:8000/v1
    api_key_env: OPENAI_API_KEY   # or leave blank if your server ignores it
    headers: {}              # add custom headers if your gateway requires them
    models:
      - id: qwen32b          # your vLLM model name
        name: Qwen 32B
        context_window: 32768
        default_max_tokens: 4096
        cost_per_1m_in: 0
        cost_per_1m_out: 0
        cost_per_1m_in_cached: 0
        cost_per_1m_out_cached: 0

	2.	Tell Crush to use your local file and skip network (one of these will usually exist in the codebase; try in this order):

	•	CRUSH_PROVIDER_FILE=/etc/crush/providers.yaml crush
	•	or CRUSH_PROVIDERS_PATH=/etc/crush/providers.yaml crush
	•	or put it in XDG config so Crush finds it automatically:
	•	Linux/macOS: ~/.config/crush/providers.yaml
	•	Windows: %APPDATA%\crush\providers.yaml

	3.	Disable online refresh (again, names vary by version—try the first one, then the next):

	•	CRUSH_SKIP_PROVIDER_UPDATE=1
	•	or CRUSH_OFFLINE=1

If Crush still tries to call out, set a fake/no-network base URL env (below) or block egress at the process level.

⸻

Option B — Tiny code patch to force offline (most robust in restricted envs)

If your environment policies allow building from source, add a file-based override in internal/config/provider.go. Example pattern:

// at top
import (
    "os"
    "gopkg.in/yaml.v3" // or std json if your file is JSON
)

func loadProvidersOfflineFirst() (Providers, error) {
    if p := os.Getenv("CRUSH_PROVIDER_FILE"); p != "" {
        b, err := os.ReadFile(p)
        if err != nil { return nil, fmt.Errorf("read providers file: %w", err) }

        var cfg struct{ Providers []Provider `yaml:"providers"` } // match existing types
        if err := yaml.Unmarshal(b, &cfg); err != nil {
            return nil, fmt.Errorf("parse providers file: %w", err)
        }
        return cfg.Providers, nil
    }
    // fall back to the existing online logic below…
}

Then in the existing load function, call loadProvidersOfflineFirst() and return early if it succeeds, so the network path is never hit when CRUSH_PROVIDER_FILE is set. Rebuild the binary and deploy just that.

If you truly can’t change code, you can also vendor the providers into the binary with //go:embed providers.yaml and load that first.

⸻

Quick sanity checklist
	•	Run once with debug logs to confirm it’s using your file:
	•	CRUSH_DEBUG=1 CRUSH_PROVIDER_FILE=~/.config/crush/providers.yaml CRUSH_SKIP_PROVIDER_UPDATE=1 crush
	•	Ensure your vLLM server is reachable from that host:
	•	curl http://127.0.0.1:8000/v1/models
	•	If you need a key header even locally, set:
	•	export OPENAI_API_KEY=dummy
	•	or add headers: {"Authorization": "Bearer dummy"} to your provider entry.

⸻

If you paste the exact error stack and (if possible) the relevant bits of provider.go (the function doing the load), I’ll give you the exact env var name/flag your build expects and the precise YAML/JSON schema Crush is parsing in that version.
